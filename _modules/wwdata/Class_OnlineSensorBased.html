
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>wwdata.Class_OnlineSensorBased &#8212; wwdata 0.1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">wwdata 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for wwdata.Class_OnlineSensorBased</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class_OnlineSensorBased provides functionalities for data handling of data obtained with online sensors in the field of (waste)water treatment.</span>
<span class="sd">Copyright (C) 2016 Chaim De Mulder</span>

<span class="sd">This program is free software: you can redistribute it and/or modify</span>
<span class="sd">it under the terms of the GNU Affero General Public License as published</span>
<span class="sd">by the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">(at your option) any later version.</span>

<span class="sd">This program is distributed in the hope that it will be useful,</span>
<span class="sd">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">GNU Affero General Public License for more details.</span>

<span class="sd">You should have received a copy of the GNU Affero General Public License</span>
<span class="sd">along with this program.  If not, see http://www.gnu.org/licenses/.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#import sys</span>
<span class="c1">#import os</span>
<span class="c1">#from os import listdir</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="c1">#import scipy as sp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>   <span class="c1">#plotten in python</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">warnings</span> <span class="k">as</span> <span class="nn">wn</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="k">as</span> <span class="nn">rn</span>

<span class="kn">from</span> <span class="nn">wwdata.Class_HydroData</span> <span class="k">import</span> <span class="n">HydroData</span>
<span class="c1">#from data_reading_functions import _print_removed_output,_log_removed_output</span>
<span class="c1">#from time_conversion_functions import *</span>

<div class="viewcode-block" id="OnlineSensorBased"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased">[docs]</a><span class="k">class</span> <span class="nc">OnlineSensorBased</span><span class="p">(</span><span class="n">HydroData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Superclass for a HydroData object, expanding the functionalities with</span>
<span class="sd">    specific functions for data gathered at full scale by continous measurements</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    timedata_column : str</span>
<span class="sd">        name of the column containing the time data</span>
<span class="sd">    data_type : str</span>
<span class="sd">        type of data provided</span>
<span class="sd">    experiment_tag : str</span>
<span class="sd">        A tag identifying the experiment; can be a date or a code used by</span>
<span class="sd">        the producer/owner of the data.</span>
<span class="sd">    time_unit : str</span>
<span class="sd">        The time unit in which the time data is given</span>
<span class="sd">    units : array</span>
<span class="sd">        The units of the variables in the columns</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">timedata_column</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">,</span><span class="n">data_type</span><span class="o">=</span><span class="s1">&#39;WWTP&#39;</span><span class="p">,</span>
                 <span class="n">experiment_tag</span><span class="o">=</span><span class="s1">&#39;No tag given&#39;</span><span class="p">,</span><span class="n">time_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        initialisation of a FullScaleSensorBased object, based on a previously defined</span>
<span class="sd">        HydroData object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HydroData</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">timedata_column</span><span class="o">=</span><span class="n">timedata_column</span><span class="p">,</span>
                           <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span><span class="n">experiment_tag</span><span class="o">=</span><span class="n">experiment_tag</span><span class="p">,</span>
                           <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filling_error</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;imputation error [%]&#39;</span><span class="p">])</span>

    <span class="c1">#def time_to_index(self,drop=True,inplace=True,verify_integrity=False):</span>
    <span class="c1">#    &quot;&quot;&quot;CONFIRMED</span>
    <span class="c1">#    using pandas set_index function to set the columns with timevalues</span>
    <span class="c1">#    as index&quot;&quot;&quot;</span>
    <span class="c1">#    # Drop second layer of indexing to make dataframe handlable</span>
    <span class="c1">#    # self.data.columns = self.data.columns.get_level_values(0)</span>
    <span class="c1">#</span>
    <span class="c1">#    if self.timename == &#39;index&#39;:</span>
    <span class="c1">#        raise IndexError(&#39;There already is a timeseries in the dataframe index!&#39;)</span>
    <span class="c1">#    if isinstance(self.time[0],str):</span>
    <span class="c1">#        raise ValueError(&#39;Time values of type &quot;str&quot; can not be used as index&#39;)</span>
    <span class="c1">#</span>
    <span class="c1">#    if inplace == False:</span>
    <span class="c1">#        new_data = self.set_index(self.timename,drop=drop,inplace=False,</span>
    <span class="c1">#                                  verify_integrity=verify_integrity)</span>
    <span class="c1">#        #self.columns = np.array(new_data.columns)</span>
    <span class="c1">#        return self.__class__(new_data,timedata_column=&#39;index&#39;,</span>
    <span class="c1">#                              data_type=self.data_type,experiment_tag=self.tag,</span>
    <span class="c1">#                              time_unit=self.time_unit)</span>
    <span class="c1">#    elif inplace == True:</span>
    <span class="c1">#        self.set_index(self.timename,drop=drop,inplace=True,</span>
    <span class="c1">#                       verify_integrity=verify_integrity)</span>
    <span class="c1">#        #self.columns = np.array(self.data.columns)</span>
    <span class="c1">#        #self.timename = &#39;index&#39;</span>
    <span class="c1">#        #self.time = self.index()</span>

<div class="viewcode-block" id="OnlineSensorBased.drop_index_duplicates"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.drop_index_duplicates">[docs]</a>    <span class="k">def</span> <span class="nf">drop_index_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        drop rows with a duplicate index. Also updates the meta_valid,</span>
<span class="sd">        meta_filled and filled dataframes</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This operation assumes the dropped rows have the same data in them and</span>
<span class="sd">        therefor no data is lost.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#self.data = self.data.groupby(self.index()).first()</span>
        <span class="c1">#self.meta_valid = self.meta_valid.groupby(self.meta_valid.index).first()</span>
        <span class="c1">#self.meta_filled = self.meta_filled.groupby(self.meta_filled.index).first()</span>
        <span class="c1">#self.filled = self.filled.groupby(self.filled.index).first()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_time</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Rows may change order using this function based on &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;string values. Convert to datetime, int or float and use &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;.sort_index() or .sort_value() to avoid. (see also hp.to_datetime())&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="OnlineSensorBased.calc_total_proportional"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.calc_total_proportional">[docs]</a>    <span class="k">def</span> <span class="nf">calc_total_proportional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Q_tot</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">conc</span><span class="p">,</span><span class="n">new_name</span><span class="o">=</span><span class="s1">&#39;new&#39;</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;mg/l&#39;</span><span class="p">,</span>
                                <span class="n">filled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the total concentration of an incoming flow, based on the</span>
<span class="sd">        given total flow and the separate incoming flows and concentrations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Q_tot : str</span>
<span class="sd">            name of the column containing the total flow</span>
<span class="sd">        Q : array of str</span>
<span class="sd">            names of the columns containing the separate flows</span>
<span class="sd">        conc : array of str</span>
<span class="sd">            names of the columns containing the separate concentration values</span>
<span class="sd">        new_name : str</span>
<span class="sd">            name of the column to be added</span>
<span class="sd">        filled : bool</span>
<span class="sd">            if true, use self.filled to calculate proportions from</span>

<span class="sd">        Note</span>
<span class="sd">        ------</span>
<span class="sd">        !!Order of columns in Q and conc must match!!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None;</span>
<span class="sd">        creates a hydropy object with added column for the proportional concentration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filled</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">index</span>
            <span class="n">sum_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)):</span>
                <span class="n">sum_</span> <span class="o">=</span> <span class="n">sum_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">conc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">Q_tot</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">()</span>
            <span class="n">sum_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)):</span>
                <span class="n">sum_</span> <span class="o">=</span> <span class="n">sum_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">conc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">Q_tot</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                                    <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="n">new_name</span><span class="p">,</span><span class="n">unit</span><span class="p">]],</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">columns</span><span class="p">)],</span>
                                    <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Something might have gone wrong with the updating of the units. &#39;</span><span class="o">+</span> \
                    <span class="s1">&#39;Check self.units to make sure everything is still okay.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
</div>
<div class="viewcode-block" id="OnlineSensorBased.calc_daily_average"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.calc_daily_average">[docs]</a>    <span class="k">def</span> <span class="nf">calc_daily_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">column_name</span><span class="p">,</span><span class="n">arange</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the daily average of values in the given column and returns them as a 2D-array,</span>
<span class="sd">        containing the days and the average values on the respective days. Plotting is possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column_name : str</span>
<span class="sd">            name of the column containing the data to calculate the average values for</span>
<span class="sd">        arange : array of two values</span>
<span class="sd">            the range within which daily averages need to be calculated</span>
<span class="sd">        plot : bool</span>
<span class="sd">            plot or not</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Dataframe :</span>
<span class="sd">            pandas dataframe, containing the daily means with standard deviations</span>
<span class="sd">            for the selected column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daily_average</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">column_name</span><span class="p">][</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Slicing not possible for index type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; and arange argument type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;. Try changing the type of the arange &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;values to one compatible with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="s2">&quot; slicing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">days</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">series</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">means</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">days</span><span class="p">]</span>
            <span class="n">stds</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">days</span><span class="p">]</span>

            <span class="n">to_return</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">days</span><span class="p">,</span><span class="n">means</span><span class="p">,</span><span class="n">stds</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">to_return</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">,</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s1">&#39;std&#39;</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pd</span><span class="o">.</span><span class="n">tslib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">means</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="n">stds</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

            <span class="n">to_return</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">means</span><span class="o">.</span><span class="n">index</span><span class="p">,</span><span class="n">means</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">stds</span><span class="o">.</span><span class="n">values</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">to_return</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">,</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s1">&#39;std&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">plot</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pd</span><span class="o">.</span><span class="n">tslib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]],</span><span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span>
                            <span class="n">yerr</span><span class="o">=</span><span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">],</span><span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">],</span><span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span>
                            <span class="n">yerr</span><span class="o">=</span><span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">],</span><span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
            <span class="c1">#ax.plot(to_return[&#39;day&#39;],(to_return[&#39;mean&#39;]+to_return[&#39;std&#39;]),&#39;b&#39;,alpha=0.5)</span>
            <span class="c1">#ax.plot(to_return[&#39;day&#39;],(to_return[&#39;mean&#39;]-to_return[&#39;std&#39;]),&#39;b&#39;,alpha=0.5)</span>
            <span class="c1">#ax.fill_between(to_return[&#39;day&#39;],to_return[&#39;mean&#39;],(to_return[&#39;mean&#39;]+to_return[&#39;std&#39;]),</span>
            <span class="c1">#                color=&#39;grey&#39;, alpha=&#39;0.3&#39;)</span>
            <span class="c1">#ax.fill_between(to_return[&#39;day&#39;],to_return[&#39;mean&#39;],(to_return[&#39;mean&#39;]-to_return[&#39;std&#39;]),</span>
            <span class="c1">#                color=&#39;grey&#39;, alpha=&#39;0.3&#39;)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">daily_average</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_return</span>
</div>
<span class="c1">#==============================================================================</span>
<span class="c1"># FILLING FUNCTIONS</span>
<span class="c1">#==============================================================================</span>
    <span class="k">def</span> <span class="nf">_reset_meta_filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reset the meta dataframe, possibly for only a certain data series,</span>
<span class="sd">        should wrong labels have been assigned at some point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data_name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">data_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">data_name</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#wn.warn(data_name + &#39; is not contained in self.meta_valid yet, so cannot\</span>
                <span class="c1">#be removed from it!&#39;)</span>

<div class="viewcode-block" id="OnlineSensorBased.add_to_filled"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.add_to_filled">[docs]</a>    <span class="k">def</span> <span class="nf">add_to_filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">column_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        column_names : array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="s1">&#39;filled&#39;</span>
        <span class="c1"># Create/adjust self.filled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># Only take the validated values to be in the self.filled dataframe in the</span>
                <span class="c1"># first place. The reindexing creates nan values where no validated</span>
                <span class="c1"># values are present</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">column</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;original&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#wn.warn(&#39;self.filled already contains a column named &#39; +</span></div>
                <span class="c1">#    column + &#39;. The original columns was kept.&#39;)</span>

    <span class="c1">#####################</span>
    <span class="c1">###   FILLING</span>
    <span class="c1">#####################</span>

<div class="viewcode-block" id="OnlineSensorBased.fill_missing_interpolation"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.fill_missing_interpolation">[docs]</a>    <span class="k">def</span> <span class="nf">fill_missing_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">to_fill</span><span class="p">,</span><span class="n">range_</span><span class="p">,</span><span class="n">arange</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills the missing values in a dataset (to_fill), based specified</span>
<span class="sd">        interpolation algorithm (method). This happens only if the number of</span>
<span class="sd">        consecutive missing values is smaller than range_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_fill : str</span>
<span class="sd">            name of the column containing the data to be filled</span>
<span class="sd">        range_ : int</span>
<span class="sd">            the maximum range that the absence of values can be to still</span>
<span class="sd">            allow interpolation to fill in values</span>
<span class="sd">        arange : array of two values</span>
<span class="sd">            the range within which missing/filtered values need to be replaced</span>
<span class="sd">        method : str</span>
<span class="sd">            interpolation method to be used by the .interpolate function. See</span>
<span class="sd">            pandas docstrings for more info</span>
<span class="sd">        plot : bool</span>
<span class="sd">            whether or not to plot the new dataset</span>
<span class="sd">        clear : bool</span>
<span class="sd">            whether or not to clear the previoulsy filled values and start from</span>
<span class="sd">            the self.meta_valid dataset again for this particular dataseries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None;</span>
<span class="sd">        creates/updates self.filled, containing the adjusted dataset and updates</span>
<span class="sd">        meta_filled with the correct labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###</span>
        <span class="c1"># CHECKS</span>
        <span class="c1">###</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="s1">&#39;filled&#39;</span>
        <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;When making use of filling functions, please make sure to &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;start filling small gaps and progressively move to larger gaps. This &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;ensures the proper working of the package algorithms.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_meta_filled</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># if the to_fill column doesn&#39;t exist yet in the meta_filled dataset,</span>
            <span class="c1"># add it, and fill it with the meta_valid values; if this last one</span>
            <span class="c1"># doesn&#39;t exist yet, create it with &#39;original&#39; tags.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># where the meta_filled dataset contains original values, update with</span>
            <span class="c1"># the values from meta_valid; in case a filling round was done before</span>
            <span class="c1"># any filtering; not supposed to happen, but cases exist.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_filled</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>

        <span class="c1"># Give warning when replacing data from rain events and at the same time</span>
        <span class="c1"># check if arange has the right type</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rain</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;WWTP&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highs</span><span class="p">[</span><span class="s1">&#39;highs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Slicing not possible for index type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; and arange argument type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;. Try changing the type of the arange &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;values to one compatible with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="s2">&quot; slicing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rain</span> <span class="p">:</span>
            <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Data points obtained during a rain event will be replaced. &#39;</span><span class="o">+</span>\
            <span class="s1">&#39;Make sure you are confident in this replacement method for the &#39;</span><span class="o">+</span>\
            <span class="s1">&#39;filling of gaps in the data during rain events.&#39;</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1"># CALCULATIONS</span>
        <span class="c1">###</span>
        <span class="c1"># Create a mask to replace the filtered datapoints with nan-values,</span>
        <span class="c1"># if consecutive occurence lower than range_</span>
        <span class="n">mask_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">mask_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span>\
                            <span class="n">shift</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">mask_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">group</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">mask_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="c1"># Compare the values in &#39;count&#39; with the ones in the group-by object.</span>
        <span class="c1"># mask_df now contains the amount of consecutive true or false datapoints,</span>
        <span class="c1"># for every datapoint</span>
        <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(</span><span class="n">group</span><span class="p">)}</span>
        <span class="n">mask_df</span> <span class="o">=</span> <span class="n">mask_df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">replace_dict</span><span class="p">)</span>

        <span class="c1"># Based on the mask and whether a datapoint is filtered, replace with</span>
        <span class="c1"># nan values</span>
        <span class="n">filtered_based</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">mask_based</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mask_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">range_</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">filtered_based</span><span class="p">,</span><span class="n">mask_based</span><span class="p">,</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1">###</span>
        <span class="c1"># FILLING</span>
        <span class="c1">###</span>
        <span class="c1"># Use the .interpolate() method to interpolate for the nan values just created</span>
        <span class="c1"># the limit argument makes sure that only the values than can be filled by</span>
        <span class="c1"># interpolation are filled; needed to prevent other, already present NaN values</span>
        <span class="c1"># from also getting filled!!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="n">range_</span><span class="p">)</span>

        <span class="c1"># Adjust in the self.meta_filled dataframe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;filled_interpol&#39;</span>

        <span class="c1"># Set all points still tagged filtered in the self.filled dataset to NaN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_analysed</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>
</div>
<div class="viewcode-block" id="OnlineSensorBased.fill_missing_ratio"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.fill_missing_ratio">[docs]</a>    <span class="k">def</span> <span class="nf">fill_missing_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">to_fill</span><span class="p">,</span><span class="n">to_use</span><span class="p">,</span><span class="n">ratio</span><span class="p">,</span><span class="n">arange</span><span class="p">,</span>
                             <span class="n">filtered_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span><span class="c1">#,use_smoothing=True):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills the missing values in a dataset (to_fill), based on the ratio this</span>
<span class="sd">        data shows when comparing to other data (to_use). This happens within</span>
<span class="sd">        the range given by arange.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_fill : str</span>
<span class="sd">            name of the column with data to fill</span>
<span class="sd">        to_use : str</span>
<span class="sd">            name of the column to use, in combination with the given ratio, to</span>
<span class="sd">            fill in some of the missing data</span>
<span class="sd">        ratio : float</span>
<span class="sd">            ratio to multiply the to_use data with to obtain data for filling in</span>
<span class="sd">            in the to_fill data column</span>
<span class="sd">        arange : array of two values</span>
<span class="sd">            the range within which missing/filtered values need to be replaced</span>
<span class="sd">        filtered_only : boolean</span>
<span class="sd">            if True, fills only the datapoints labeled as filtered. If False,</span>
<span class="sd">            fills/replaces all datapoints in the given range</span>
<span class="sd">        plot : bool</span>
<span class="sd">            whether or not to plot the new dataset</span>
<span class="sd">        clear : bool</span>
<span class="sd">            whether or not to clear the previoulsy filled values and start from</span>
<span class="sd">            the self.meta_valid dataset again for this particular dataseries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None;</span>
<span class="sd">        creates/updates self.filled, containing the adjusted dataset and updates</span>
<span class="sd">        meta_filled with the correct labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###</span>
        <span class="c1"># CHECKS</span>
        <span class="c1">###</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="s1">&#39;filled&#39;</span>
        <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;When making use of filling functions, please make sure to &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;start filling small gaps and progressively move to larger gaps. This &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;ensures the proper working of the package algorithms.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_meta_filled</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># if the to_fill column doesn&#39;t exist yet in the meta_filled dataset,</span>
            <span class="c1"># add it, and fill it with the meta_valid values; if this last one</span>
            <span class="c1"># doesn&#39;t exist yet, create it with &#39;original&#39; tags.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># where the meta_filled dataset contains original values, update with</span>
            <span class="c1"># the values from meta_valid; in case a filling round was done before</span>
            <span class="c1"># any filtering; not supposed to happen, but cases exist.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_filled</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>

        <span class="c1"># Give warning when replacing data from rain events and at the same time</span>
        <span class="c1"># check if arange has the right type</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rain</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;WWTP&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highs</span><span class="p">[</span><span class="s1">&#39;highs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Slicing not possible for index type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; and arange argument type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;. Try changing the type of the arange &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;values to one compatible with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="s2">&quot; slicing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rain</span> <span class="p">:</span>
            <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Data points obtained during a rain event will be replaced. &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;Make sure you are confident in this replacement method for the &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;filling of gaps in the data during rain events.&#39;</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1"># FILLING</span>
        <span class="c1">###</span>
        <span class="k">if</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span>\
                                    <span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span>\
                                    <span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">to_use</span><span class="p">]</span><span class="o">*</span><span class="n">ratio</span>
            <span class="c1"># Adjust in the self.meta_filled dataframe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;filled_ratio&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">to_use</span><span class="p">]</span><span class="o">*</span><span class="n">ratio</span>
            <span class="c1"># Adjust in the self.meta_valid dataframe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;filled_ratio&#39;</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_analysed</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>
</div>
<div class="viewcode-block" id="OnlineSensorBased.fill_missing_correlation"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.fill_missing_correlation">[docs]</a>    <span class="k">def</span> <span class="nf">fill_missing_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">to_fill</span><span class="p">,</span><span class="n">to_use</span><span class="p">,</span><span class="n">arange</span><span class="p">,</span><span class="n">corr_range</span><span class="p">,</span>
                                 <span class="n">zero_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">filtered_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills the missing values in a dataset (to_fill), based on the correlation</span>
<span class="sd">        this data shows when comparing to other data (to_use). This happens within</span>
<span class="sd">        the range given by arange.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_fill : str</span>
<span class="sd">            name of the column with data to fill</span>
<span class="sd">        to_use : str</span>
<span class="sd">            name of the column to use, in combination with the given ratio, to</span>
<span class="sd">            fill in some of the missing data</span>
<span class="sd">        arange : array of two values</span>
<span class="sd">            the range within which missing/filtered values need to be replaced</span>
<span class="sd">        corr_range : array of two values</span>
<span class="sd">            the range to use for the calculation of the correlation</span>
<span class="sd">        filtered_only : boolean</span>
<span class="sd">            if True, fills only the datapoints labeled as filtered. If False,</span>
<span class="sd">            fills/replaces all datapoints in the given range</span>
<span class="sd">        plot : bool</span>
<span class="sd">            whether or not to plot the new dataset</span>
<span class="sd">        clear : bool</span>
<span class="sd">            whether or not to clear the previoulsy filled values and start from</span>
<span class="sd">            the self.meta_valid dataset again for this particular dataseries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None;</span>
<span class="sd">        creates/updates self.filled, containing the adjusted dataset and updates</span>
<span class="sd">        meta_filled with the correct labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###</span>
        <span class="c1"># CHECKS</span>
        <span class="c1">###</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="s1">&#39;filled&#39;</span>
        <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;When making use of filling functions, please make sure to &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;start filling small gaps and progressively move to larger gaps. This &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;ensures the proper working of the package algorithms.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_meta_filled</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># if the to_fill column doesn&#39;t exist yet in the meta_filled dataset,</span>
            <span class="c1"># add it, and fill it with the meta_valid values; if this last one</span>
            <span class="c1"># doesn&#39;t exist yet, create it with &#39;original&#39; tags.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># where the meta_filled dataset contains original values, update with</span>
            <span class="c1"># the values from meta_valid; in case a filling round was done before</span>
            <span class="c1"># any filtering; not supposed to happen, but cases exist.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_filled</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>

        <span class="c1"># Give warning when replacing data from rain events and at the same time</span>
        <span class="c1"># check if arange has the right type</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rain</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;WWTP&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highs</span><span class="p">[</span><span class="s1">&#39;highs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Slicing not possible for index type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; and arange argument type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;. Try changing the type of the arange &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;values to one compatible with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="s2">&quot; slicing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rain</span> <span class="p">:</span>
            <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Data points obtained during a rain event will be replaced.&#39;</span> <span class="o">+</span> \
            <span class="s1">&#39; Make sure you are confident in this replacement method for the&#39;</span> <span class="o">+</span> \
            <span class="s1">&#39; filling of gaps in the data during rain events.&#39;</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1"># CALCULATIONS</span>
        <span class="c1">###</span>
        <span class="n">slope</span><span class="p">,</span><span class="n">intercept</span><span class="p">,</span><span class="n">r_sq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_correlation</span><span class="p">(</span><span class="n">to_use</span><span class="p">,</span><span class="n">to_fill</span><span class="p">,</span><span class="n">corr_range</span><span class="p">,</span>
                                                    <span class="n">zero_intercept</span><span class="o">=</span><span class="n">zero_intercept</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">intercept</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The intercept was calculated to be lower than &#39;</span><span class="o">+</span> \
                <span class="s1">&#39;0, which might lead to negative data values when data is replaced &#39;</span><span class="o">+</span> \
                <span class="s1">&#39;based on this correlation. Try setting &quot;zero_intercept&quot; to True &#39;</span><span class="o">+</span> \
                <span class="s1">&#39;to avoid.&#39;</span><span class="p">)</span>
        <span class="c1">###</span>
        <span class="c1"># FILLING</span>
        <span class="c1">###</span>
        <span class="k">if</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span>\
                                            <span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span>\
                                            <span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">to_use</span><span class="p">]</span><span class="o">*</span><span class="n">slope</span> <span class="o">+</span> <span class="n">intercept</span>
            <span class="c1"># Adjust in the self.meta_filled dataframe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;filled_correlation&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">to_use</span><span class="p">]</span><span class="o">*</span><span class="n">slope</span> <span class="o">+</span> <span class="n">intercept</span>
            <span class="c1"># Adjust in the self.meta_filled dataframe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;filled_correlation&#39;</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_analysed</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>
</div>
<div class="viewcode-block" id="OnlineSensorBased.fill_missing_standard"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.fill_missing_standard">[docs]</a>    <span class="k">def</span> <span class="nf">fill_missing_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">to_fill</span><span class="p">,</span><span class="n">arange</span><span class="p">,</span><span class="n">filtered_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills the missing values in a dataset (to_fill), based on the average</span>
<span class="sd">        daily profile calculated by calc_daily_profile(). This happens within</span>
<span class="sd">        the range given by arange.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_fill : str</span>
<span class="sd">            name of the column with data to fill</span>
<span class="sd">        arange : array of two values</span>
<span class="sd">            the range within which missing/filtered values need to be replaced</span>
<span class="sd">        filtered_only : boolean</span>
<span class="sd">            if True, fills only the datapoints labeled as filtered. If False,</span>
<span class="sd">            fills/replaces all datapoints in the given range</span>
<span class="sd">        plot : bool</span>
<span class="sd">            whether or not to plot the new dataset</span>
<span class="sd">        clear : bool</span>
<span class="sd">            whether or not to clear the previoulsy filled values and start from</span>
<span class="sd">            the self.meta_valid dataset again for this particular dataseries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None;</span>
<span class="sd">        creates/updates self.filled, containing the adjusted dataset and updates</span>
<span class="sd">        meta_filled with the correct labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###</span>
        <span class="c1"># CHECKS</span>
        <span class="c1">###</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="s1">&#39;filled&#39;</span>
        <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;When making use of filling functions, please make sure to &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;start filling small gaps and progressively move to larger gaps. This &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;ensures the proper working of the package algorithms.&#39;</span><span class="p">)</span>

        <span class="c1"># several checks on availability of the right columns in the necessary</span>
        <span class="c1"># dataframes/dictionaries</span>
        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_meta_filled</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># if the to_fill column doesn&#39;t exist yet in the meta_filled dataset,</span>
            <span class="c1"># add it, and fill it with the meta_valid values; if this last one</span>
            <span class="c1"># doesn&#39;t exist yet, create it with &#39;original&#39; tags.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># where the meta_filled dataset contains original values, update with</span>
            <span class="c1"># the values from meta_valid; in case a filling round was done before</span>
            <span class="c1"># any filtering; not supposed to happen, but cases exist.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_filled</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">daily_profile</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;self.daily_profile should be a dictionary Type. </span><span class="se">\</span>
<span class="s2">                Run calc_daily_profile() to get an average daily profile for &quot;</span> <span class="o">+</span> <span class="n">to_fill</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;self.daily_profile doesn&#39;t exist yet, meaning &quot;</span><span class="o">+</span>
            <span class="s2">&quot;there is no data available to replace other data with. Run &quot;</span><span class="o">+</span>
            <span class="s2">&quot;calc_daily_profile() to get an average daily profile for &quot;</span> <span class="o">+</span> <span class="n">to_fill</span><span class="p">)</span>

        <span class="c1"># Give warning when replacing data from rain events and at the same time</span>
        <span class="c1"># check if arange has the right type</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rain</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;WWTP&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highs</span><span class="p">[</span><span class="s1">&#39;highs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Slicing not possible for index type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; and arange argument type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;. Try changing the type of the arange &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;values to one compatible with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="s2">&quot; slicing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rain</span> <span class="p">:</span>
            <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Data points obtained during a rain event will be replaced. &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;Make sure you are confident in this replacement method for the &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;filling of gaps in the data during rain events.&#39;</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1"># CALCULATIONS</span>
        <span class="c1">###</span>
        <span class="n">daily_profile</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">daily_profile</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">daily_profile</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="s1">&#39;avg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
        <span class="n">daily_profile</span> <span class="o">=</span> <span class="n">daily_profile</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">daily_profile</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">daily_profile</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">daily_profile</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>

        <span class="c1">###</span>
        <span class="c1"># FILLING</span>
        <span class="c1">###</span>
        <span class="k">if</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span>\
                                            <span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span>\
                                            <span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                              <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">time</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">daily_profile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">index_value</span><span class="p">]</span> <span class="k">for</span> <span class="n">index_value</span> <span class="ow">in</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;time_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">find_nearest_time</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">daily_profile</span><span class="p">,</span><span class="s1">&#39;time&#39;</span><span class="p">))</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;time_index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vlookup_day</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">daily_profile</span><span class="p">,</span><span class="s1">&#39;data&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># Adjust in the self.meta_valid dataframe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;filled_average_profile&#39;</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_analysed</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>
</div>
<div class="viewcode-block" id="OnlineSensorBased.fill_missing_model"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.fill_missing_model">[docs]</a>    <span class="k">def</span> <span class="nf">fill_missing_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">to_fill</span><span class="p">,</span><span class="n">to_use</span><span class="p">,</span><span class="n">arange</span><span class="p">,</span><span class="n">filtered_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills the missing values in a dataset (to_fill), based on the modeled</span>
<span class="sd">        values given in to_use. This happens within the range given by arange.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_fill : str</span>
<span class="sd">            name of the column with data to fill</span>
<span class="sd">        to_use : pd.Series</span>
<span class="sd">            pandas series containing the modeled data with which the filtered</span>
<span class="sd">            data can be replaced</span>
<span class="sd">        arange : array of two values</span>
<span class="sd">            the range within which missing/filtered values need to be replaced</span>
<span class="sd">        filtered_only : boolean</span>
<span class="sd">            if True, fills only the datapoints labeled as filtered. If False,</span>
<span class="sd">            fills/replaces all datapoints in the given range</span>
<span class="sd">        unit : str</span>
<span class="sd">            the unit in which the modeled values are given; datetime values will</span>
<span class="sd">            be converted to values with that unit. Possible: sec, min, hr, d</span>
<span class="sd">        plot : bool</span>
<span class="sd">            whether or not to plot the new dataset</span>
<span class="sd">        clear : bool</span>
<span class="sd">            whether or not to clear the previoulsy filled values and start from</span>
<span class="sd">            the self.meta_valid dataset again for this particular dataseries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None;</span>
<span class="sd">        creates/updates self.filled, containing the adjusted dataset and updates</span>
<span class="sd">        meta_filled with the correct labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###</span>
        <span class="c1"># CHECKS</span>
        <span class="c1">###</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="s1">&#39;filled&#39;</span>
        <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;When making use of filling functions, please make sure to &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;start filling small gaps and progressively move to larger gaps. This &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;ensures the proper working of the package algorithms.&#39;</span><span class="p">)</span>

        <span class="c1"># several checks on availability of the right columns in the necessary</span>
        <span class="c1"># dataframes/dictionaries</span>
        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_meta_filled</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># if the to_fill column doesn&#39;t exist yet in the meta_filled dataset,</span>
            <span class="c1"># add it, and fill it with the meta_valid values; if this last one</span>
            <span class="c1"># doesn&#39;t exist yet, create it with &#39;original&#39; tags.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># where the meta_filled dataset contains original values, update with</span>
            <span class="c1"># the values from meta_valid; in case a filling round was done before</span>
            <span class="c1"># any filtering; not supposed to happen, but cases exist.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_filled</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>

        <span class="c1"># Give warning when replacing data from rain events and at the same time</span>
        <span class="c1"># check if arange has the right type</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rain</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;WWTP&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highs</span><span class="p">[</span><span class="s1">&#39;highs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Slicing not possible for index type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; and arange argument type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;. Try changing the type of the arange &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;values to one compatible with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="s2">&quot; slicing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rain</span> <span class="p">:</span>
            <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Data points obtained during a rain event will be replaced. &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;Make sure you are confident in this replacement method for the &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;filling of gaps in the data during rain events.&#39;</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1"># CALCULATIONS</span>
        <span class="c1">###</span>
        <span class="c1">#model_values = to_use.name</span>
        <span class="n">model_values</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">to_use</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">model_values</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_use</span><span class="o">.</span><span class="n">index</span>
        <span class="n">model_values</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_use</span><span class="o">.</span><span class="n">values</span>

        <span class="c1">###</span>
        <span class="c1"># FILLING</span>
        <span class="c1">###</span>
        <span class="k">if</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span>\
                                            <span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span>\
                                            <span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span>\
                                            <span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_values</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="c1"># if datatype of time of modeled vs data values doesn&#39;t match, convert to absolute values</span>
            <span class="c1"># (floats)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;abs_indexes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">absolute_to_relative</span><span class="p">(</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">],</span>
                                                    <span class="n">start_date</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
                <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;time_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;abs_indexes&#39;</span><span class="p">]</span><span class="o">.</span>\
                                                    <span class="n">apply</span><span class="p">(</span><span class="n">find_nearest_time</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">model_values</span><span class="p">,</span><span class="s1">&#39;time&#39;</span><span class="p">))</span>
            <span class="k">except</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;No indexes were found to replace. Check the &#39;</span><span class="o">+</span> \
                <span class="s1">&#39;range in which you want to replace values, or check if filtered &#39;</span><span class="o">+</span> \
                <span class="s1">&#39;values actually exist in the meta_filled dataset.&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;time_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]</span><span class="o">.</span>\
                                               <span class="n">apply</span><span class="p">(</span><span class="n">find_nearest_time</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">model_values</span><span class="p">,</span><span class="s1">&#39;time&#39;</span><span class="p">))</span>

        <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;time_index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vlookup_day</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">model_values</span><span class="p">,</span><span class="s1">&#39;data&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># Adjust in the self.meta_valid dataframe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;filled_infl_model&#39;</span>

            <span class="c1">#self.filled.loc[arange[0]:arange[1],to_fill] = to_use.values</span>
            <span class="c1"># Adjust in the self.meta_valid dataframe</span>
            <span class="c1">#self.meta_filled.loc[arange[0]:arange[1],to_fill] = &#39;filled_model&#39;</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_analysed</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>
</div>
<div class="viewcode-block" id="OnlineSensorBased.fill_missing_daybefore"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.fill_missing_daybefore">[docs]</a>    <span class="k">def</span> <span class="nf">fill_missing_daybefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">to_fill</span><span class="p">,</span><span class="n">arange</span><span class="p">,</span><span class="n">range_to_replace</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
                               <span class="n">filtered_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills the missing values in a dataset (to_fill), based on the data values</span>
<span class="sd">        from the day before the range starts. These data values are based on</span>
<span class="sd">        the self.filled dataset and therefor can contain filled datapoints as well.</span>
<span class="sd">        This happens within the range given by arange.</span>
<span class="sd">        !! IMPORTANT !!</span>
<span class="sd">        This function will not work on datasets with non-equidistant data points!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_fill : str</span>
<span class="sd">            name of the column with data to fill</span>
<span class="sd">        arange : array of two values</span>
<span class="sd">            the range within which missing/filtered values need to be replaced</span>
<span class="sd">        range_to_replace : array of two int/float values</span>
<span class="sd">            the minimum and maximum amount of time (i.e. min and max size of</span>
<span class="sd">            gaps in data) where missing datapoints can be replaced using this</span>
<span class="sd">            function, i.e. using values of the last day before measurements</span>
<span class="sd">            went bad.</span>
<span class="sd">        filtered_only : boolean</span>
<span class="sd">            if True, fills only the datapoints labeled as filtered. If False,</span>
<span class="sd">            fills/replaces all datapoints in the given range</span>
<span class="sd">        plot : bool</span>
<span class="sd">            whether or not to plot the new dataset</span>
<span class="sd">        clear : bool</span>
<span class="sd">            whether or not to clear the previoulsy filled values and start from</span>
<span class="sd">            the self.meta_valid dataset again for this particular dataseries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None;</span>
<span class="sd">        creates/updates self.filled, containing the adjusted dataset and updates</span>
<span class="sd">        meta_filled with the correct labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###</span>
        <span class="c1"># CHECKS</span>
        <span class="c1">###</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="s1">&#39;filled&#39;</span>
        <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;When making use of filling functions, please make sure to &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;start filling small gaps and progressively move to larger gaps. This &#39;</span><span class="o">+</span> \
        <span class="s1">&#39;ensures the proper working of the package algorithms.&#39;</span><span class="p">)</span>
        <span class="c1"># index checks</span>
        <span class="c1">#if arange[0] &lt; 1 or arange[1] &gt; self.index()[-1]:</span>
        <span class="c1">#    raise IndexError(&#39;Index out of bounds. Check whether the values of \</span>
        <span class="c1">#    &quot;arange&quot; are within the index range of the data. Mind that the first \</span>
        <span class="c1">#    day of data cannot be replaced with this algorithm!&#39;)</span>

        <span class="c1"># several checks on availability of the right columns in the necessary</span>
        <span class="c1"># dataframes/dictionaries</span>
        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_meta_filled</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># if the to_fill column doesn&#39;t exist yet in the meta_filled dataset,</span>
            <span class="c1"># add it, and fill it with the meta_valid values; if this last one</span>
            <span class="c1"># doesn&#39;t exist yet, create it with &#39;original&#39; tags.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># where the meta_filled dataset contains original values, update with</span>
            <span class="c1"># the values from meta_valid; in case a filling round was done before</span>
            <span class="c1"># any filtering; not supposed to happen, but cases exist.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_meta_valid</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_fill</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_filled</span><span class="p">([</span><span class="n">to_fill</span><span class="p">])</span>

        <span class="c1"># Give warning when replacing data from rain events and at the same time</span>
        <span class="c1"># check if arange has the right type</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rain</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;WWTP&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highs</span><span class="p">[</span><span class="s1">&#39;highs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Slicing not possible for index type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; and arange argument type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;. Try changing the type of the arange &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;values to one compatible with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="s2">&quot; slicing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rain</span> <span class="p">:</span>
            <span class="n">wn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Data points obtained during a rain event will be replaced. &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;Make sure you are confident in this replacement method for the &#39;</span><span class="o">+</span> \
            <span class="s1">&#39;filling of gaps in the data during rain events.&#39;</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1"># CALCULATIONS</span>
        <span class="c1">###</span>
        <span class="c1"># Get data to fill the missing data with, i.e. data from the day before,</span>
        <span class="c1"># and convert indices to relative ones per day; parallel for</span>
        <span class="c1"># self.meta_filled</span>

        <span class="c1"># check if arange[0] is equal to beginning of the dataset; if this is</span>
        <span class="c1"># the case, change it to one day further for the coming code to work</span>


        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">oneday</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">oneday</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;No data from the day before available, &quot;</span><span class="o">+</span>\
                                 <span class="s2">&quot;adjust the range for replacement.&quot;</span><span class="p">)</span>
                <span class="c1">#arange[0] = arange[0] + oneday</span>
                <span class="c1">#wn.warn(&quot;The range for replacement given in the arange argument &quot;+\</span>
                <span class="c1">#        &quot;included the first day of data. The range was adjusted to&quot;+\</span>
                <span class="c1">#        &quot;start one day later.&quot;)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">oneday</span><span class="p">:</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">oneday</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">oneday</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;No data from the day before available, &quot;</span><span class="o">+</span>\
                                 <span class="s2">&quot;adjust the range for replacement.&quot;</span><span class="p">)</span>
                <span class="c1">#arange[0] = arange[0] + oneday</span>
                <span class="c1">#wn.warn(&quot;The range for replacement given in the arange argument &quot;+\</span>
                <span class="c1">#        &quot;included the first day of data. The range was adjusted to&quot;+\</span>
                <span class="c1">#        &quot;start one day later.&quot;)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">oneday</span><span class="p">:</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="n">day_before</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">oneday</span><span class="p">:</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                  <span class="n">index</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
        <span class="n">day_before</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        <span class="n">day_before</span> <span class="o">=</span> <span class="n">day_before</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span><span class="o">.</span>\
                     <span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>

        <span class="n">range_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_before</span><span class="p">)</span>
        <span class="n">range_to_replace</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_to_replace</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_before</span><span class="p">)</span>

        <span class="c1"># Create a mask to replace the filtered datapoints with nan-values,</span>
        <span class="c1"># if consecutive occurence lower than range_</span>
        <span class="n">mask_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">mask_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span>\
                            <span class="n">shift</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">mask_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">group</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">mask_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="c1"># Compare the values in &#39;count&#39; with the ones in the group-by object.</span>
        <span class="c1"># mask_df now contains the amount of consecutive true or false datapoints,</span>
        <span class="c1"># for every datapointday</span>
        <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(</span><span class="n">group</span><span class="p">)}</span>
        <span class="n">mask_df</span> <span class="o">=</span> <span class="n">mask_df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">replace_dict</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1"># FILLING</span>
        <span class="c1">###</span>
        <span class="c1"># Based on the mask and whether a datapoint is filtered, replace with</span>
        <span class="c1"># nan values</span>
        <span class="k">if</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="n">filtered_based</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span>\
                                           <span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                           <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filtered_only</span><span class="p">:</span>
            <span class="n">filtered_based</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">arange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                           <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span>

        <span class="n">mask_based</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mask_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">range_to_replace</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span>\
                                          <span class="n">loc</span><span class="p">[</span><span class="n">mask_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">range_to_replace</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span>\
                                          <span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span>
        <span class="c1">#mask_based.columns = [&#39;indexes&#39;]</span>
        <span class="c1"># if all values are still original in meta_valid, don&#39;t use mask_based, because this</span>
        <span class="c1"># can contain no values and make that nothing is filled</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">to_fill</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;original&#39;</span><span class="p">]):</span>
            <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">filtered_based</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexes_to_replace</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">filtered_based</span><span class="p">,</span><span class="n">mask_based</span><span class="p">,</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>

        <span class="c1"># look up the values to replace with in the day_before dataset</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">time</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">day_before</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">index_value</span><span class="p">]</span> <span class="k">for</span> <span class="n">index_value</span> <span class="ow">in</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;time_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">find_nearest_time</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">day_before</span><span class="p">,</span><span class="s1">&#39;time&#39;</span><span class="p">))</span>
            <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;time_index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vlookup_day</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">day_before</span><span class="p">,</span><span class="s1">&#39;data&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># Adjust in the self.meta_valid dataframe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_filled</span><span class="p">[</span><span class="n">to_fill</span><span class="p">][</span><span class="n">indexes_to_replace</span><span class="p">[</span><span class="s1">&#39;indexes&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;filled_profile_day_before&#39;</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_analysed</span><span class="p">(</span><span class="n">to_fill</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>
</div>

    <span class="c1">#####################</span>
    <span class="c1">###   CHECKING</span>
    <span class="c1">#####################</span>

    <span class="k">def</span> <span class="nf">_create_gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data_name</span><span class="p">,</span><span class="n">range_</span><span class="p">,</span><span class="n">number</span><span class="p">,</span><span class="n">max_size</span><span class="p">,</span><span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">user_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly creates gaps in the data by introducing fake &#39;filtered&#39; tags in</span>
<span class="sd">        meta_valid. This artificial creation of gaps can be filled later to</span>
<span class="sd">        test the reliability of the filling algorithms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_name : string</span>
<span class="sd">            name of the column containing the data to create gaps in</span>
<span class="sd">        range_ : 2-element array</span>
<span class="sd">            the range within which gaps need to be created</span>
<span class="sd">        number : int</span>
<span class="sd">            number of gaps to create</span>
<span class="sd">        max_size : int</span>
<span class="sd">            maximum size of the gaps, expressed in data points</span>
<span class="sd">        reset : boolean</span>
<span class="sd">            if True, the meta_valid dataframe is set back to &#39;original&#39; values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None; creates a self.meta_valid dataframe containing &#39;fake&#39; tags</span>
<span class="sd">        creating artificial gaps in the data.</span>

<span class="sd">        !!!</span>
<span class="sd">        Watch out when using this on the original dataset, as tags might be</span>
<span class="sd">        changed or removed when using this function.</span>
<span class="sd">        !!!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a new meta_valid dataframe with original values</span>
        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_meta_valid</span><span class="p">(</span><span class="n">data_name</span><span class="p">)</span>

        <span class="c1"># get index locations of range_</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">list_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">ilocs</span> <span class="o">=</span> <span class="p">[</span><span class="n">list_</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">range_</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="n">list_</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">range_</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Slicing not possible for index type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; and range_ argument type &quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">range_</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;. Try changing the type of the range_ &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;values to one compatible with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="s2">&quot; slicing.&quot;</span><span class="p">)</span>

        <span class="c1"># create random positions where to create gaps</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">rn</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">ilocs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ilocs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">)]</span>

        <span class="c1"># create random sizes with maximum size of max_size</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">rn</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_size</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))]</span>

        <span class="c1"># define integer indexes where gaps need to be created (i.e. &#39;filtered&#39;</span>
        <span class="c1"># in meta_valid)</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span><span class="n">sizes</span><span class="p">)]</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">])</span>
        <span class="c1"># replace values when higher than length of the dataset with the maximum position</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span><span class="n">ilocs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ilocs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># create gaps by replacing data with 0; not nan, because this will</span>
        <span class="c1"># complicate comparison with filled values when using check_filling_error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">data_name</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">locations</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># create gaps in meta_valid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">locations</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;filtered&#39;</span>

        <span class="k">if</span> <span class="n">user_output</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">data_name</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="s1">&#39;original&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; </span><span class="si">% o</span><span class="s2">f datapoints left after creating gaps&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_filling_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data_name</span><span class="p">,</span><span class="n">filling_function</span><span class="p">,</span><span class="n">test_data_range</span><span class="p">,</span>
                                 <span class="n">nr_small_gaps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">max_size_small_gaps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                 <span class="n">nr_large_gaps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">max_size_large_gaps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a filling error based on the articial and random creation of</span>
<span class="sd">        gaps in a dataset, subsequent filling of those gaps with a defined</span>
<span class="sd">        algorithm and comparison of the filling results with the original data.</span>
<span class="sd">        Because this happens randomly, results differ every time this function</span>
<span class="sd">        is used. To get an average of the errors, run check_filling_error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        please refer to the check_filling_error docstring for the parameter</span>
<span class="sd">        definitions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Average filling error</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">test_data_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">test_data_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">gaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">test_data_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">test_data_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">gaps</span><span class="o">.</span><span class="n">get_highs</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,[</span><span class="n">test_data_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">test_data_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>


        <span class="c1"># create gaps;</span>
        <span class="k">if</span> <span class="n">nr_small_gaps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gaps</span><span class="o">.</span><span class="n">_create_gaps</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">],</span><span class="n">nr_large_gaps</span><span class="p">,</span><span class="n">max_size_large_gaps</span><span class="p">,</span><span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nr_large_gaps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gaps</span><span class="o">.</span><span class="n">_create_gaps</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">],</span><span class="n">nr_small_gaps</span><span class="p">,</span><span class="n">max_size_small_gaps</span><span class="p">,</span><span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gaps</span><span class="o">.</span><span class="n">_create_gaps</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">],</span><span class="n">nr_small_gaps</span><span class="p">,</span><span class="n">max_size_small_gaps</span><span class="p">,</span><span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">gaps</span><span class="o">.</span><span class="n">_create_gaps</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">],</span><span class="n">nr_large_gaps</span><span class="p">,</span><span class="n">max_size_large_gaps</span><span class="p">,</span><span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># create a column in gaps.filled containing the artificial gaps; this</span>
        <span class="c1"># avoids calling of the add_to_filled function in the filling functions</span>
        <span class="c1"># which would reset gaps.filled to the original dataset and make</span>
        <span class="c1"># comparing after data imputation impossible</span>
        <span class="n">gaps</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">gaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">data_name</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_name</span><span class="p">],</span>
                                   <span class="n">index</span> <span class="o">=</span> <span class="n">gaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># fill gaps</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filling_function</span> <span class="o">==</span> <span class="s1">&#39;fill_missing_interpolation&#39;</span><span class="p">:</span>
                <span class="n">gaps</span><span class="o">.</span><span class="n">fill_missing_interpolation</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_fill&#39;</span><span class="p">],</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;range_&#39;</span><span class="p">],</span>
                                                <span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">filling_function</span> <span class="o">==</span> <span class="s1">&#39;fill_missing_ratio&#39;</span><span class="p">:</span>
                <span class="n">gaps</span><span class="o">.</span><span class="n">fill_missing_ratio</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_fill&#39;</span><span class="p">],</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_use&#39;</span><span class="p">],</span>
                                        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;ratio&#39;</span><span class="p">],</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">filling_function</span> <span class="o">==</span> <span class="s1">&#39;fill_missing_correlation&#39;</span><span class="p">:</span>
                <span class="n">gaps</span><span class="o">.</span><span class="n">fill_missing_correlation</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_fill&#39;</span><span class="p">],</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_use&#39;</span><span class="p">],</span>
                                              <span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">],</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;corr_range&#39;</span><span class="p">],</span>
                                              <span class="n">options</span><span class="p">[</span><span class="s1">&#39;zero_intercept&#39;</span><span class="p">])</span>


            <span class="k">elif</span> <span class="n">filling_function</span> <span class="o">==</span> <span class="s1">&#39;fill_missing_standard&#39;</span><span class="p">:</span>
                <span class="n">gaps</span><span class="o">.</span><span class="n">calc_daily_profile</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_fill&#39;</span><span class="p">],</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">])</span>
                <span class="n">gaps</span><span class="o">.</span><span class="n">fill_missing_standard</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_fill&#39;</span><span class="p">],</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">filling_function</span> <span class="o">==</span> <span class="s1">&#39;fill_missing_model&#39;</span><span class="p">:</span>
                <span class="n">gaps</span><span class="o">.</span><span class="n">fill_missing_model</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_fill&#39;</span><span class="p">],</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_use&#39;</span><span class="p">],</span>
                                        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">filling_function</span> <span class="o">==</span> <span class="s1">&#39;fill_missing_daybefore&#39;</span><span class="p">:</span>
                <span class="c1"># make a copy of options, because otherwise the object keeps on changing</span>
                <span class="c1"># in every for-iteration of the check_filling_error function</span>
                <span class="n">arange</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
                          <span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="c1"># check if there is a &#39;day before&#39; to do filling; this will not be</span>
                <span class="c1"># the case, because length of the dataset and to_fill range are the</span>
                <span class="c1"># same, but checking in this way still needs to happen because of</span>
                <span class="c1"># the for-loop in the check_filling_error function</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gaps</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
                    <span class="n">oneday</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">gaps</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">oneday</span><span class="p">:</span>
                        <span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">oneday</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gaps</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">float</span><span class="p">):</span>
                    <span class="n">oneday</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">gaps</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">oneday</span><span class="p">:</span>
                        <span class="n">arange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;arange&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">oneday</span>

                <span class="n">gaps</span><span class="o">.</span><span class="n">fill_missing_daybefore</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;to_fill&#39;</span><span class="p">],</span><span class="n">arange</span><span class="p">,</span>
                                            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;range_to_replace&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Entered filling function is not available for testing.&quot;</span><span class="p">)</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Filling function could not be executed. Check &quot;</span><span class="o">+</span>\
                            <span class="s2">&quot;docstring of the filling function to provide &quot;</span><span class="o">+</span>\
                            <span class="s2">&quot;appropriate arguments.&quot;</span><span class="p">)</span>

        <span class="n">indexes_to_compare</span> <span class="o">=</span> <span class="n">gaps</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">gaps</span><span class="o">.</span><span class="n">meta_valid</span><span class="p">[</span><span class="n">data_name</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;filtered&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">deviations</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">data_name</span><span class="p">][</span><span class="n">indexes_to_compare</span><span class="p">]</span> <span class="o">-</span>
                          <span class="n">gaps</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">data_name</span><span class="p">][</span><span class="n">indexes_to_compare</span><span class="p">])</span><span class="o">/</span> \
                      <span class="n">orig</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">data_name</span><span class="p">][</span><span class="n">indexes_to_compare</span><span class="p">])</span>
        <span class="c1"># drop inf values and calculate average</span>
        <span class="n">avg_deviation</span> <span class="o">=</span> <span class="n">deviations</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">deviations</span><span class="p">[</span><span class="n">deviations</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">*</span><span class="mi">100</span>

        <span class="k">if</span> <span class="n">avg_deviation</span> <span class="o">==</span> <span class="mf">100.000000</span><span class="p">:</span>
            <span class="c1"># if avg deviation is 100, this means that gaps.filled was 0 on all</span>
            <span class="c1"># indexes to compare, which is exactly the same as was defined `</span>
            <span class="c1"># befor the filling, i.e. no data were filled.</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">avg_deviation</span>

<div class="viewcode-block" id="OnlineSensorBased.check_filling_error"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.OnlineSensorBased.check_filling_error">[docs]</a>    <span class="k">def</span> <span class="nf">check_filling_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nr_iterations</span><span class="p">,</span><span class="n">data_name</span><span class="p">,</span><span class="n">filling_function</span><span class="p">,</span>
                            <span class="n">test_data_range</span><span class="p">,</span>
                            <span class="n">nr_small_gaps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">max_size_small_gaps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">nr_large_gaps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">max_size_large_gaps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the _calculate_filling_error function (refer to that docstring for</span>
<span class="sd">        more specific info) to calculate the error on the data points that are</span>
<span class="sd">        filled with a certain algorithm.</span>
<span class="sd">        Because _calculate_filling_error inserts random gaps, results differ</span>
<span class="sd">        every time it is used. Check_filling_error averages this out.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nr_iterations : int</span>
<span class="sd">            The number of iterations to run for the calculation of the imputation</span>
<span class="sd">            error</span>
<span class="sd">        data_name : string</span>
<span class="sd">            name of the column containing the data the filling reliability needs</span>
<span class="sd">            to be checked for.</span>
<span class="sd">        filling function : str, wdata filling function</span>
<span class="sd">            the name of the filling function to be tested for reliability</span>
<span class="sd">        test_data_range : array of two values</span>
<span class="sd">            an array containing the start and end point of the test data to be used.</span>
<span class="sd">            IMPORTANT: for testing filling with correlation, this range needs to</span>
<span class="sd">            include the range for correlation calculation and the filling range.</span>
<span class="sd">        nr_small_gaps / nr_large_gaps: int</span>
<span class="sd">            the number of small/large gaps to create in the dataset for testing</span>
<span class="sd">        max_size_small_gaps / max_size_large_gaps: int</span>
<span class="sd">            the maximum size of the gaps inserted in the data, expressed in data</span>
<span class="sd">            points</span>
<span class="sd">        **options:</span>
<span class="sd">            Arguments for the filling function; refer to the relevant filling</span>
<span class="sd">            function to know what arguments to give</span>

<span class="sd">        Note</span>
<span class="sd">        ------</span>
<span class="sd">        When checking for the error on data filling, a period (arange argument)</span>
<span class="sd">        with mostly reliable data should be used. If for example large gaps are</span>
<span class="sd">        already present in the given data, this will heavily influence the</span>
<span class="sd">        returned error, as filled values will be compared with the values from</span>
<span class="sd">        the data gap.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            adds the average filling error the self.filling_error dataframe</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># shut off warnings, to avoid e.g. warning about replacing datapoints</span>
        <span class="c1"># in wet weather</span>
        <span class="n">wn</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nr_small_gaps</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nr_large_gaps</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No information was provided to make the gaps &quot;</span><span class="o">+</span>\
                                 <span class="s2">&quot;with. Please specify the number of small or &quot;</span><span class="o">+</span>\
                                 <span class="s2">&quot;large gaps you want to create for testing&quot;</span><span class="p">)</span>

        <span class="n">filling_errors</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nr_iterations</span><span class="p">):</span>
            <span class="n">iter_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_filling_error</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span><span class="n">filling_function</span><span class="p">,</span><span class="n">test_data_range</span><span class="p">,</span>
                                                       <span class="n">nr_small_gaps</span><span class="o">=</span><span class="n">nr_small_gaps</span><span class="p">,</span>
                                                       <span class="n">max_size_small_gaps</span><span class="o">=</span><span class="n">max_size_small_gaps</span><span class="p">,</span>
                                                       <span class="n">nr_large_gaps</span><span class="o">=</span><span class="n">nr_large_gaps</span><span class="p">,</span>
                                                       <span class="n">max_size_large_gaps</span><span class="o">=</span><span class="n">max_size_large_gaps</span><span class="p">,</span>
                                                       <span class="o">**</span><span class="n">options</span><span class="p">)</span>
            <span class="c1">#print(options_filling_function)</span>
            <span class="k">if</span> <span class="n">iter_error</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># turn warnings on again</span>
                <span class="n">wn</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Checking of the filling function could not &quot;</span><span class="o">+</span>\
                                 <span class="s2">&quot;be executed. Check docstring of the filling &quot;</span><span class="o">+</span>\
                                 <span class="s2">&quot;function to provide appropriate arguments.&quot;</span><span class="p">)</span>

            <span class="n">filling_errors</span> <span class="o">=</span> <span class="n">filling_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">iter_error</span><span class="p">]))</span>

        <span class="n">avg</span> <span class="o">=</span> <span class="n">filling_errors</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filling_error</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">data_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Average deviation of imputed points from the original ones is &#39;</span><span class="o">+</span>\
              <span class="nb">str</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%. This value is also saved in self.filling_error.&quot;</span><span class="p">)</span>

        <span class="c1"># turn warnings on again</span>
        <span class="n">wn</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
</div></div>

<span class="c1">#==============================================================================</span>
<span class="c1"># LOOKUP FUNCTIONS</span>
<span class="c1">#==============================================================================</span>

<div class="viewcode-block" id="find_nearest_time"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.find_nearest_time">[docs]</a><span class="k">def</span> <span class="nf">find_nearest_time</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">df</span><span class="p">,</span><span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the (time) value in a dataframe column nearest to a given value</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : float</span>
<span class="sd">        time value to find the closest value for in &#39;df&#39;</span>
<span class="sd">    df : pd.Dataframe</span>
<span class="sd">        dataframe to use</span>
<span class="sd">    column : str</span>
<span class="sd">        column to check &#39;value&#39; against</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">-</span><span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="vlookup_day"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.vlookup_day">[docs]</a><span class="k">def</span> <span class="nf">vlookup_day</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">df</span><span class="p">,</span><span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the dataframe index of a given value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
</div>

<span class="c1">####START ADJUSTING HERE NEXT TIME!</span>

<div class="viewcode-block" id="drop_peaks"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.drop_peaks">[docs]</a><span class="k">def</span> <span class="nf">drop_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data_name</span><span class="p">,</span><span class="n">cutoff</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters out the peaks larger than a cut-off value in a dataseries</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_name : str</span>
<span class="sd">        the name of the column to use for the removal of peak values</span>
<span class="sd">    cutoff : int</span>
<span class="sd">        cut off value to use for the removing of peaks; values with an</span>
<span class="sd">        absolute value larger than this cut off will be removed from the data</span>
<span class="sd">    inplace : bool</span>
<span class="sd">        indicates whether a new dataframe is created and returned or whether</span>
<span class="sd">        the operations are executed on the existing dataframe (nothing is</span>
<span class="sd">        returned)</span>
<span class="sd">    log_file : str</span>
<span class="sd">        string containing the directory to a log file to be written out</span>
<span class="sd">        when using this function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    LabSensorBased object (if inplace=False)</span>
<span class="sd">        the dataframe from which the double values of &#39;data&#39; are removed</span>
<span class="sd">    None (if inplace=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data_name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">log_file</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_print_removed_output</span><span class="p">(</span><span class="n">original</span><span class="p">,</span><span class="n">new</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">log_file</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">_log_removed_output</span><span class="p">(</span><span class="n">log_file</span><span class="p">,</span><span class="n">original</span><span class="p">,</span><span class="n">new</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Please provide the location of the log file as &#39;</span><span class="o">+</span> \
                            <span class="s1">&#39;a string type, or leave the argument if no log &#39;</span><span class="o">+</span> \
                            <span class="s1">&#39;file is needed.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">timename</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">inplace</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">data_name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">log_file</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_print_removed_output</span><span class="p">(</span><span class="n">original</span><span class="p">,</span><span class="n">new</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">log_file</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">_log_removed_output</span><span class="p">(</span><span class="n">log_file</span><span class="p">,</span><span class="n">original</span><span class="p">,</span><span class="n">new</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Please provide the location of the log file as &#39;</span><span class="o">+</span> \
                            <span class="s1">&#39;a string type, or leave the argument if no log &#39;</span><span class="o">+</span> \
                            <span class="s1">&#39;file is needed.&#39;</span><span class="p">)</span>
</div>

<span class="k">def</span> <span class="nf">_select_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">down</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span><span class="c1">#,based_on_max=True):#,bounds=[1,1]):</span>

    <span class="c1">#TO BE ADJUSTED BASED ON ALL FUNCTIONS FILE!</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects down- or upward sloping data from a given dataseries, based on</span>
<span class="sd">    the maximum in the dataseries. This requires only one maximum to be</span>
<span class="sd">    present in the dataset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ydata : str</span>
<span class="sd">        name of the column containing the data for which slopes, either up</span>
<span class="sd">        or down, need to be selected</span>
<span class="sd">    down : bool</span>
<span class="sd">        if True, the downwards slopes are selected, if False, the upward</span>
<span class="sd">        slopes</span>
<span class="sd">    based_on_max : bool</span>
<span class="sd">        if True, the data is selected based on the maximum of the data, if</span>
<span class="sd">        false it is based on the minimum</span>
<span class="sd">    bounds : array</span>
<span class="sd">        array containing two integer values, indicating the extra margin of</span>
<span class="sd">        values that needs to be dropped from the dataset to avoid selecting</span>
<span class="sd">        irregular data (e.g. not straightened out after reaching of maximum)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    LabSensorBased object:</span>
<span class="sd">        a dataframe from which the non-down or -upward sloping data are dropped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#if based_on_max == True:</span>
    <span class="n">drop_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ydata</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">down</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Selecting downward slope:&#39;</span><span class="p">,</span><span class="n">drop_index</span><span class="p">,</span>\
            <span class="s1">&#39;datapoints dropped,&#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">drop_index</span><span class="p">,</span>\
            <span class="s1">&#39;datapoints left.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">drop_index</span><span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">timename</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span><span class="c1">#IndexError:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not enough datapoints left for selection&#39;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">down</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Selecting upward slope:&#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">drop_index</span><span class="p">,</span>\
            <span class="s1">&#39;datapoints dropped,&#39;</span><span class="p">,</span><span class="n">drop_index</span><span class="p">,</span><span class="s1">&#39;datapoints left.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">drop_index</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">timename</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span><span class="c1">#IndexError:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not enough datapoints left for selection&#39;</span><span class="p">)</span>

    <span class="c1">#    elif based_on_max == False:</span>
    <span class="c1">#        drop_index = dataframe[ydata].idxmin()</span>
    <span class="c1">#        if down == True:</span>
    <span class="c1">#            try:</span>
    <span class="c1">#                print &#39;Selecting downward slope:&#39;,drop_index+sum(bounds),\</span>
    <span class="c1">#                &#39;datapoints dropped,&#39;,len(dataframe)-drop_index-sum(bounds),\</span>
    <span class="c1">#                &#39;datapoints left.&#39;</span>
    <span class="c1">#</span>
    <span class="c1">#                dataframe = dataframe[bounds[0]:drop_index-bounds[1]]</span>
    <span class="c1">#                dataframe.reset_index(drop=True,inplace=True)</span>
    <span class="c1">#                return dataframe</span>
    <span class="c1">#            except IndexError:</span>
    <span class="c1">#                print &#39;Not enough datapoints left for selection&#39;</span>
    <span class="c1">#</span>
    <span class="c1">#        elif down == False:</span>
    <span class="c1">#            try:</span>
    <span class="c1">#                print &#39;Selecting upward slope:&#39;,len(dataframe)-drop_index+sum(bounds),\</span>
    <span class="c1">#                &#39;datapoints dropped,&#39;,drop_index-sum(bounds),&#39;datapoints left.&#39;</span>
    <span class="c1">#</span>
    <span class="c1">#                dataframe = dataframe[drop_index+bounds[0]:-bounds[1]]</span>
    <span class="c1">#                dataframe.reset_index(drop=True,inplace=True)</span>
    <span class="c1">#                return dataframe</span>
    <span class="c1">#            except IndexError:</span>
    <span class="c1">#                print &#39;Not enough datapoints left for selection&#39;</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="go_WEST"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.go_WEST">[docs]</a><span class="k">def</span> <span class="nf">go_WEST</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span><span class="n">time_data</span><span class="p">,</span><span class="n">WEST_name_conversion</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves a WEST compatible file (influent or other inputs)</span>

<span class="sd">    parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw_data: str or pd DataFrame</span>

<span class="sd">    time_data:</span>

<span class="sd">    WEST_name_conversion: pd DataFrame with column names: WEST, units and RAW</span>
<span class="sd">        dataframe containing three columns: the column names for the WEST-compatible file,</span>
<span class="sd">        the units to appear in the WEST-compatible file and the column names of the raw</span>
<span class="sd">        data file.</span>

<span class="sd">    output</span>
<span class="sd">    ------</span>
<span class="sd">    None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#if type(raw_data) == str:</span>
    <span class="c1">#    try data = pd.read_csv(raw_data,sep= &#39;\t&#39;)</span>
    <span class="c1">#    except print(&#39;Provide valid file name (including path) to read.&#39;)</span>
    <span class="c1">#else:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span>
    <span class="c1">#if not data.columns == WEST_name_conversion[&#39;raw_data_name&#39;]</span>
    <span class="c1">#    print(&#39;raw data columns should be the same as the raw data colum values given in WEST_name_conversion&#39;)</span>
    <span class="c1">#    return None</span>

    <span class="n">WEST_compatible</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">WEST_name_conversion</span><span class="p">)):</span>
        <span class="n">WEST_compatible</span><span class="p">[</span><span class="n">WEST_name_conversion</span><span class="p">[</span><span class="s1">&#39;WEST&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">WEST_name_conversion</span><span class="p">[</span><span class="s1">&#39;RAW&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">help_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">WEST_name_conversion</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">help_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">WEST_compatible</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="n">WEST_compatible</span> <span class="o">=</span> <span class="n">help_df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WEST_compatible</span><span class="p">)</span>
    <span class="n">WEST_compatible</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;#t&#39;</span><span class="p">,</span><span class="n">time_data</span><span class="p">)</span>
    <span class="n">WEST_compatible</span><span class="p">[</span><span class="s1">&#39;#t&#39;</span><span class="p">][</span><span class="s1">&#39;units&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;#d&#39;</span>
    <span class="k">return</span> <span class="n">WEST_compatible</span>
</div>


<span class="c1">###############################################################################</span>
<span class="c1">##                          HELP FUNCTIONS                                   ##</span>
<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">_print_removed_output</span><span class="p">(</span><span class="n">original</span><span class="p">,</span><span class="n">new</span><span class="p">,</span><span class="n">type_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function printing the output of functions that remove datapoints.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original : int</span>
<span class="sd">        original length of the dataset</span>
<span class="sd">    new : int</span>
<span class="sd">        length of the new dataset</span>
<span class="sd">    type_ : str</span>
<span class="sd">        &#39;removed&#39; or &#39;dropped&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Original dataset:&#39;</span><span class="p">,</span><span class="n">original</span><span class="p">,</span><span class="s1">&#39;datapoints&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;New dataset:&#39;</span><span class="p">,</span><span class="n">new</span><span class="p">,</span><span class="s1">&#39;datapoints&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">original</span><span class="o">-</span><span class="n">new</span><span class="p">,</span><span class="s1">&#39;datapoints &#39;</span><span class="p">,</span><span class="n">type_</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_log_removed_output</span><span class="p">(</span><span class="n">log_file</span><span class="p">,</span><span class="n">original</span><span class="p">,</span><span class="n">new</span><span class="p">,</span><span class="n">type_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function writing the output of functions that remove datapoints to a log file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_file : str</span>
<span class="sd">        string containing the directory to the log file to be written out</span>
<span class="sd">    original : int</span>
<span class="sd">        original length of the dataset</span>
<span class="sd">    new : int</span>
<span class="sd">        length of the new dataset</span>
<span class="sd">    type_ : str</span>
<span class="sd">        &#39;removed&#39; or &#39;dropped&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">log_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_file</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Original dataset: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">original</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; datapoints; new dataset: &#39;</span><span class="o">+</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; datapoints&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">original</span><span class="o">-</span><span class="n">new</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; datapoints &#39;</span><span class="p">,</span><span class="n">type_</span><span class="p">))</span>
    <span class="n">log_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="total_seconds"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.total_seconds">[docs]</a><span class="k">def</span> <span class="nf">total_seconds</span><span class="p">(</span><span class="n">timedelta_value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">timedelta_value</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="absolute_to_relative"><a class="viewcode-back" href="../../wwdata.html#wwdata.Class_OnlineSensorBased.absolute_to_relative">[docs]</a><span class="k">def</span> <span class="nf">absolute_to_relative</span><span class="p">(</span><span class="n">series</span><span class="p">,</span><span class="n">start_date</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="n">decimals</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    converts a pandas series with datetime timevalues to relative timevalues</span>
<span class="sd">    in the given unit, starting from start_date</span>

<span class="sd">    parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series : pd.Series</span>
<span class="sd">        series of datetime of comparable values</span>
<span class="sd">    unit : str</span>
<span class="sd">        unit to which to convert the time values (sec, min, hr or d)</span>

<span class="sd">    output</span>
<span class="sd">    ------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">time_delta</span> <span class="o">=</span> <span class="n">series</span> <span class="o">-</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span><span class="p">(</span><span class="s1">&#39;IndexError&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;The passed series appears to be empty. To calculate &#39;</span> <span class="o">+</span> \
        <span class="s1">&#39;a relative timeseries, an absolute timeseries is necessary.&#39;</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">total_seconds</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_date</span><span class="p">)</span>

    <span class="n">relative</span> <span class="o">=</span> <span class="n">time_delta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">total_seconds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;sec&#39;</span><span class="p">:</span>
        <span class="n">relative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">relative</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
        <span class="n">relative</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">relative</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;hr&#39;</span><span class="p">:</span>
        <span class="n">relative</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">relative</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span>
        <span class="n">relative</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">relative</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">24</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">relative</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">wwdata 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Chaim De Mulder.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>